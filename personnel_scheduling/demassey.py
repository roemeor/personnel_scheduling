# AUTOGENERATED! DO NOT EDIT! File to edit: 01_demassey.ipynb (unless otherwise specified).

__all__ = ['DemasseyInstance', 'RuleSet']

# Cell

import os

import numpy as np

from .data_structures import *
from .reporting import *

from collections import namedtuple

from box import Box
from dataclasses import dataclass, field

# Cell


class DemasseyInstance():

    def __init__(self, filename):

        self.instance_name = filename[filename.rfind('/')+1:-4]

        with open(filename) as f:
            self.number_of_periods = int(f.readline())
            self.max_work_periods_per_shift = int(f.readline())
            self.number_of_days_in_horizon = int(f.readline())
            self.is_continous = int(f.readline())
            self.instance_version = int(f.readline())
            self.meaningless_parameter = int(f.readline())
            self.number_of_employees =int(f.readline()[5:])
            self.skills = ([int(n) for n in f.readline()[:-1].split()])
            self.number_of_activities = int(f.readline()[4:])

            line_ints = [int(n) for n in f.readline()[:-1].split()]

            self.min_cons_periods = line_ints[0]
            self.max_cons_periods = line_ints[1]
            self.cost_per_activity_assignment = line_ints[2]

            self.activity_data = []

            for act in range(self.number_of_activities):
                self.activity_data.append( Box() )
                self.activity_data[act].demand = ([int(n) for n in f.readline()[:-1].split()])
                self.activity_data[act].over_covering_cost = ([int(n) for n in f.readline()[:-1].split()])
                self.activity_data[act].under_covering_cost = ([int(n) for n in f.readline()[:-1].split()])
                self.activity_data[act].demand_2 = ([int(n) for n in f.readline()[:-1].split()])
                f.readline()


    def get_aggregated_demand_per_period(self):
        demand_per_period = []
        for p in range(self.number_of_periods):
            demand = 0
            for act in range(self.number_of_activities):
                demand = demand + self.activity_data[act].demand[p]

            demand_per_period.append(demand)

        return demand_per_period

    def get_activity_demands_per_period(self):
        demands = []

        for activity in range(self.number_of_activities):
            demands.append(self.activity_data[activity].demand)

        return demands


    def get_average_work_hours(self):
        return (np.sum(self.get_aggregated_demand_per_period()) / self.number_of_employees) / 4

    def get_instance_information(self):
        return f'Info: Activities: {self.number_of_activities}, Employees: {self.number_of_employees}, âŒ€ Workhours: {self.get_average_work_hours():.02f}'


# Cell


class RuleSet:

    def __init__(self, instance):
        self.instance = instance

    def check_activity_block_rules(self, activity_block):

        evaluation_result = RuleEvaluationResult()

        number_of_periods = activity_block.get_number_of_periods()



        # if it is a work block: minimum activity
        if activity_block.is_work():

            evaluation_result.add_penalty('ActivityCostPerPeriod', activity_block.get_number_of_work_periods() * self.instance.cost_per_activity_assignment )


            if number_of_periods < self.instance.min_cons_periods:
                evaluation_result.add_hard_rule_violation('MinConsPeriodsActivity')

            elif number_of_periods > self.instance.max_cons_periods:
                evaluation_result.add_hard_rule_violation('MaxConsPeriodsActivity')
        else:
            if number_of_periods not in [1, 4]:
                evaluation_result.add_hard_rule_violation('EitherShortOrLunchBreak')


        return evaluation_result

    def check_work_block_rules(self, work_block, shift_index = -1):
        # between two different activities we need a break

        evaluation_result = RuleEvaluationResult()

        prev_block = work_block.activity_blocks[0]

        for block in work_block.activity_blocks[1:]:
            if prev_block.activity_type != block.activity_type:
                return evaluation_result.add_hard_rule_violation('BreakBetweenActivitiesNeeded')

            prev_block = block

        return evaluation_result

    def check_shift_rules(self, shift, shift_index = -1):
        # for this type of problem, we need to ensure that

        # 1. between two different activities we need a break
        # 2. between two breaks, there needs to be work.

        evaluation_result = RuleEvaluationResult()

        short_breaks = []
        lunch_breaks = []


        hard_rule_violations = []

        prev_block = shift.work_and_break_blocks[0]
        number_of_work_periods = prev_block.get_number_of_work_periods()

        for block in shift.work_and_break_blocks[1:]:
            if prev_block.is_work() == block.is_work():
                evaluation_result.add_hard_rule_violation('BreakAndWorkBlocksNeedToAlternate')

            #oberve: given the activity block checks, we know that we can only have 1 and 4 period-breaks
            if not block.is_work():
                if block.get_number_of_break_periods() == 1:
                    short_breaks.append(block)
                else:
                    lunch_breaks.append(block)


            number_of_work_periods += block.get_number_of_work_periods()

            prev_block = block

        # now check:
        if number_of_work_periods < 6*4:
            if not (len(short_breaks)==1 and len(lunch_breaks) == 0):
                evaluation_result.add_hard_rule_violation('OneShortBreakOnlyInShortShift')
        elif number_of_work_periods <= self.instance.max_work_periods_per_shift:
            if not (len(short_breaks)==2 and len(lunch_breaks) == 1):
                    evaluation_result.add_hard_rule_violation('TwoShortBreakAndOneLunchInLongShift')
        else:
            evaluation_result.add_hard_rule_violation('MaxWorkPeriodsPerShift')

        return evaluation_result


    def check_demand_coverage(self, p, activity, covered_demand):
        evaluation_result = RuleEvaluationResult()

        difference = covered_demand - self.instance.activity_data[activity].demand[p]


        if difference > 0: ## over-covering
             evaluation_result.add_penalty('OverCovering',difference * self.instance.activity_data[activity].over_covering_cost[p])
        elif difference < 0:
            evaluation_result.add_penalty('UnderCovering',(-1)*difference * self.instance.activity_data[activity].under_covering_cost[p])

        return evaluation_result


